"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[763],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(t),h=r,d=u["".concat(c,".").concat(h)]||u[h]||f[h]||i;return t?a.createElement(d,o(o({ref:n},p),{},{components:t})):a.createElement(d,o({ref:n},p))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=h;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var s=2;s<i;s++)o[s]=t[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},3412:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>f,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:0},o="SEF Reference Flash Translation Layer (FTL)",l={unversionedId:"FTL/overview",id:"FTL/overview",title:"SEF Reference Flash Translation Layer (FTL)",description:"chap-SefFtl}",source:"@site/docs/FTL/overview.md",sourceDirName:"FTL",slug:"/FTL/overview",permalink:"/SEF-SDK/FTL/overview",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"docs",previous:{title:"SEF Library",permalink:"/SEF-SDK/Library/overview"},next:{title:"Block Layer",permalink:"/SEF-SDK/FTL/block"}},c={},s=[],p={toc:s},u="wrapper";function f(e){let{components:n,...t}=e;return(0,r.kt)(u,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"chap-SefFtl"},"SEF Reference Flash Translation Layer (FTL)"),(0,r.kt)("p",null,"The Software-Enabled Flash\u2122\ufe0f (SEF) Reference FTL implements an asynchronous user mode\nblock API using the SEF Library. The implementation serves as an example of how to use the SEF\nLibrary and demonstrates the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Managing a Flash Translation Layer (FTL) with multiple placement IDs"),(0,r.kt)("li",{parentName:"ul"},"Persisting and recovering FTL metadata"),(0,r.kt)("li",{parentName:"ul"},"Background garbage collection using I/O priority control"),(0,r.kt)("li",{parentName:"ul"},"Handling and accounting for device wear")),(0,r.kt)("p",null,"The code is implemented with simplicity in mind. Parts of the Reference FTL can be used in other\nprojects or expanded and enhanced based on project requirements and needs."),(0,r.kt)("p",null,"The SEF Reference FTL is implemented as a shared library. The public, ",(0,r.kt)("inlineCode",{parentName:"p"},"C-11 API")," is defined in\n",(0,r.kt)("inlineCode",{parentName:"p"},"sef-block-module.h"),". It implements an asynchronous block API using a host-based flash translation layer (FTL).\nGarbage collection is handled by the Reference FTL and supports a QoS Domain\nconfigured with multiple placement IDs. Over-provisioning is set with a one-time configuration of\na fresh QoS Domain by calling ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockConfig"},"SEFBlockConfig"),". Once configured,\na context for a QoS Domain is obtained by calling ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockInit"},"SEFBlockInit"),". The\nreturned context is required when issuing I/O with ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockIO"},"SEFBlockIO"),"."),(0,r.kt)("p",null,"I/O is only asynchronous and inherits the threading model of the SEF Library. The FTL is designed\nto have no locking for reads, and, given adequate over-provisioning, limited locking for writes. Reads\nare never queued, and writes are only queued by the FTL when there are no available Super Blocks\nin the QoS Domain. The writes are queued until GC can recover a free Super Block. Garbage\ncollection runs when the end of the over-provisioning is encountered. Blocked writes waiting for GC\ncan be canceled by calling ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockCancel"},"SEFBlockCancel"),"."),(0,r.kt)("p",null,"The FTL\u2019s LBA-to-flash address lookup table (LUT) is kept entirely in\nRAM. It is loaded in ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockInit"},"SEFBlockInit")," and saved in\n",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockCleanup"},"SEFBlockCleanup"),". In the case of a client/system crash,\nthe saved LUT will be out of date but marked as dirty. When this happens,\n",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockInit"},"SEFBlockInit")," will fail. The LUT can be both checked and repaired\nby calling ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockCheck"},"SEFBlockCheck"),". The current implementation\nrebuilds the LUT entirely from Super Block metadata, but the internal function that does the work\nis capable of updating a stale LUT by only processing the metadata of Super Blocks written after\nthe LUT was last saved."),(0,r.kt)("p",null,"The SDK is made up of 7 components:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/SEF-SDK/FTL/block#chap-Block"},"Block Layer")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/SEF-SDK/FTL/flash-translation-layer#chap-FlashTranslationLayer"},"Flash Translation Layer")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/SEF-SDK/FTL/superblock-management#chap-SuperBlockStateManagement"},"Super Block State Management")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/SEF-SDK/FTL/garbage-collection#chap-GarbageCollection"},"Garbage Collection")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/SEF-SDK/FTL/persistence#chap-Persistence"},"Persistence")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/SEF-SDK/FTL/instrumentation#chap-Instrumentation"},"Instrumentation")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/SEF-SDK/FTL/logging#chap-Logging"},"Logging"))),(0,r.kt)("p",null,"These sections document the internals and theory of operation for each layer."))}f.isMDXComponent=!0}}]);