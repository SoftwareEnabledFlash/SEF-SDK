"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[546],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),p=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(d.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=r,h=u["".concat(d,".").concat(c)]||u[c]||m[c]||o;return n?a.createElement(h,i(i({ref:t},s),{},{components:n})):a.createElement(h,i({ref:t},s))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9184:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:0},i="Flexible I/O Tester (FIO)",l={unversionedId:"FIO/overview",id:"FIO/overview",title:"Flexible I/O Tester (FIO)",description:"chap-fio}",source:"@site/docs/FIO/overview.md",sourceDirName:"FIO",slug:"/FIO/overview",permalink:"/SEF-SDK/FIO/overview",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"docs",previous:{title:"Extending SEF CLI",permalink:"/SEF-SDK/CLI/extending-cli"},next:{title:"QEMU",permalink:"/SEF-SDK/QEMU/overview"}},d={},p=[{value:"SEF FIO Engine Options",id:"tab-SefFioOptions",level:4},{value:"Listing 1: Example SEF Engine FIO Job",id:"code-FioExample",level:4},{value:"Buddy Allocator",id:"buddy-allocator",level:2}],s={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"chap-fio"},"Flexible I/O Tester (FIO)"),(0,r.kt)("p",null,"The Software-Enabled Flash\u2122\ufe0f (SEF) patch for ",(0,r.kt)("inlineCode",{parentName:"p"},"fio")," adds SEF as an I/O engine. The SEF I/O\nengine uses the SEF Block Module to issue block I/O against a defined QoS Domain. In other\nwords, the QoS Domain which is used should be defined before the job is executed. If the QoS\nDomain is not configured, the engine will configure it using default values."),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FIO/overview#tab-SefFioOptions"},"SEF FIO Engine Options")," Table enumerates the options accepted by the\nSEF I/O engine. ",(0,r.kt)("inlineCode",{parentName:"p"},"qos_domain_id")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"qos_domain_label")," option should be provided to identify\nthe target QoS Domain. If both options are provided, ",(0,r.kt)("inlineCode",{parentName:"p"},"qos_domain_id")," is used as default. The\n",(0,r.kt)("inlineCode",{parentName:"p"},"qos_domain_label")," should be unique across the SEF Unit or the job will fail."),(0,r.kt)("h4",{id:"tab-SefFioOptions"},"SEF FIO Engine Options"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Option"),(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Required"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sef_unit_index"),(0,r.kt)("td",{parentName:"tr",align:null},"int (16 bit)"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes"),(0,r.kt)("td",{parentName:"tr",align:null},"The index of the SEF Unit, the index is zero based")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"qos_domain_id"),(0,r.kt)("td",{parentName:"tr",align:null},"int (16 bit)"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes*"),(0,r.kt)("td",{parentName:"tr",align:null},"The Id of the QoS Domain")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"qos_domain_label"),(0,r.kt)("td",{parentName:"tr",align:null},"uint (Two 64 bits)"),(0,r.kt)("td",{parentName:"tr",align:null},"Yes*"),(0,r.kt)("td",{parentName:"tr",align:null},"The label of the QoS Domain")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sef_zero_copy"),(0,r.kt)("td",{parentName:"tr",align:null},"bool"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Use zero copy buffers")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"read_queue"),(0,r.kt)("td",{parentName:"tr",align:null},"int (16 bit)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"kSEFRead queue override when valid")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"read_weight"),(0,r.kt)("td",{parentName:"tr",align:null},"int (16 bit)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Read weight to override when non-zero")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"write_weight"),(0,r.kt)("td",{parentName:"tr",align:null},"int (16 bit)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Write weight to override when non-zero")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"placement_id"),(0,r.kt)("td",{parentName:"tr",align:null},"int (16 bit)"),(0,r.kt)("td",{parentName:"tr",align:null},"No"),(0,r.kt)("td",{parentName:"tr",align:null},"Placement ID for writes")))),(0,r.kt)("p",null,"Listing ",(0,r.kt)("a",{parentName:"p",href:"#code-FioExample"},"1")," is an example job file that runs for 10 minutes. It contains two jobs,\nboth operating on SEF Unit 0. The first randomly writes to QoS Domain 2, and the second reads\nand writes to a QoS Domain labeled as ",(0,r.kt)("inlineCode",{parentName:"p"},"61300673829223,888776657572036"),"."),(0,r.kt)("p",null,"It\u2019s important to note the ",(0,r.kt)("inlineCode",{parentName:"p"},"thread")," option. It\u2019s required because the SEF Block Module and SEF\nlibraries do not currently support forked processes."),(0,r.kt)("h4",{id:"code-FioExample"},"Listing 1: Example SEF Engine FIO Job"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[global]\nioengine=sef\nsef_unit_index=0\nbs=4k\ntime_based=1\nruntime=600\nverify=md5\niodepth=16\nthread\n\n\n[sef-write]\nqos_domain_id=2\nrw=randwrite\nsize=100%\n\n\n[sef-read-write]\nqos_domain_label=61300673829223,888776657572036\nrw=randrw\nsize=100%\n")),(0,r.kt)("h2",{id:"buddy-allocator"},"Buddy Allocator"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"sef_zero_copy")," option of the SEF FIO Engine uses the Buddy Allocator to write the\ndata."),(0,r.kt)("p",null,'The Buddy Allocator works by associating fragmented memory with the incoming I/O requests and\nfreeing them as I/O get completed. The buddy allocator allocates blocks of memory in multiples of\na fixed size\u2014in this case, the ADU size. A pool of memory is pre-allocated by the buddy allocator\nin a power-of-2 of the fixed size. Free lists are maintained for each power-of-2 from the fixed size\nto the size of the whole pool. The buddy allocator begins searching for free blocks at the smallest\npower-of-2 which is larger than the requested allocation. If space can\u2019t be found there, the next\nlargest level is checked until space is found. The block there will be split, and the unallocated\nportion of the block will be assigned to the lower power-of-2 free list. When blocks are freed, a\n"buddy" is looked for in the matching power-of-2 list, and if found, the blocks are combined and\nmoved to the higher power-of-2 list.'),(0,r.kt)("p",null,"Unlike a regular heap, it is possible to use blocks from within a previous allocation."),(0,r.kt)("p",null,"For the SEF FIO engine, we allocate a pool that is larger than the size of the outstanding I/O, and\nthe blocks are returned to the buddy allocator when the nameless write completes."))}m.isMDXComponent=!0}}]);