"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[404],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>f});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),c=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(a),p=n,f=h["".concat(s,".").concat(p)]||h[p]||u[p]||i;return a?r.createElement(f,o(o({ref:t},d),{},{components:a})):r.createElement(f,o({ref:t},d))}));function f(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:n,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},8914:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=a(7462),n=(a(7294),a(3905));const i={sidebar_position:1},o="Block Layer",l={unversionedId:"FTL/block",id:"FTL/block",title:"Block Layer",description:"chap-Block}",source:"@site/docs/FTL/block.md",sourceDirName:"FTL",slug:"/FTL/block",permalink:"/SEF-SDK/FTL/block",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docs",previous:{title:"SEF Reference Flash Translation Layer (FTL)",permalink:"/SEF-SDK/FTL/overview"},next:{title:"Flash Translation Layer",permalink:"/SEF-SDK/FTL/flash-translation-layer"}},s={},c=[{value:"I/O",id:"io",level:2},{value:"Figure 2: Write Example 1",id:"fig-WriteExample1",level:4},{value:"Figure 3: Write Example 2",id:"fig-WriteExample2",level:4},{value:"I/O priority",id:"io-priority",level:2},{value:"Delayed Writes",id:"sec-delayedWrites",level:2},{value:"Crash Recovery",id:"crash-recovery",level:3}],d={toc:c},h="wrapper";function u(e){let{components:t,...i}=e;return(0,n.kt)(h,(0,r.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"chap-Block"},"Block Layer"),(0,n.kt)("p",null,"The block layer is the public API for the Reference FTL and implements an asynchronous block API.\nIt uses the flash translation layer (FTL) to map user LBAs to device flash addresses. The properties\nof a configured QoS Domain are read using ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockGetInfo"},"SEFBlockGetInfo"),". The\n",(0,n.kt)("inlineCode",{parentName:"p"},"deferMount")," member in struct ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#struct-SEFBlockOption"},"SEFBlockOption")," can be set to ",(0,n.kt)("inlineCode",{parentName:"p"},"true"),"\nto create a context to quickly access properties without having to perform a full initialization."),(0,n.kt)("h2",{id:"io"},"I/O"),(0,n.kt)("p",null,"Block I/O is issued by calling ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockIO"},"SEFBlockIO"),". It places no restriction on\nthe size of a write, but the SEF Library will break large writes up into multiple smaller writes based\non device and operating system limits. There is also no restriction on the size of a read, but large\nreads will be broken up into smaller reads of contiguous runs of flash addresses. Typically, if data\nwas written with one write, it can be read with one read until it crosses a Super Block boundary.\nHowever, after portions are rewritten by the client or have been moved on flash as part of a garbage\ncollection (GC), runs can be shortened. More SEF read requests will be required to read the same\ndata. This is handled automatically by the block layer for the caller."),(0,n.kt)("p",null,"As an example, this is a section of the LUT and a newly erased Super Block after two writes. The\nfirst was a write to LBA 0 of 3 ADUs in blue and the second was a write to LBA 4 of 3 ADUs in\nyellow."),(0,n.kt)("h4",{id:"fig-WriteExample1"},"Figure 2: Write Example 1"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Write Example 1",src:a(9688).Z,width:"400",height:"441"})),(0,n.kt)("p",null,"When a client issues a read of LBA 0 through 6, internally the block layer will need to issue 3 calls\nto ",(0,n.kt)("inlineCode",{parentName:"p"},"sbmWholeRead()"),". The flash addresses are contiguous, but the LBA addresses are not. The\nfirst call will issue a read for LBA0/ADU0 of 3 ADUs, the second call will not issue a read, but\nwill fill the buffer for LBA 3 with zeros and the third call will issue a read for LBA4/ADU3 of 3\nADUs."),(0,n.kt)("p",null,"After the gap at LBA 3 is filled by a third write in green to LBA 2 of 3 ADUs, this is how the LUT\nand Super Block appear:"),(0,n.kt)("h4",{id:"fig-WriteExample2"},"Figure 3: Write Example 2"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Write Example 2",src:a(2447).Z,width:"400",height:"441"})),(0,n.kt)("p",null,"The gap at LBA 3 has been filled. ADUs 2 and 3 are colored red because they are unreachable\nthrough the LUT and have been marked as invalid in the Super Block layer. GC skips ADUs\nmarked as invalid. Another result of the write is the flash addresses are no longer contiguous. A\nclient reading LBAs 0 through 6 will result in 3 calls to ",(0,n.kt)("inlineCode",{parentName:"p"},"sbmWholeRead()"),". The first call will issue\na read for LBA0/ADU0 of 2 ADUs, the second call will issue a read for LBA2/ADU6 of 3 ADUs\nand the third call will issue a read for LBA5/ADU4 of 2 ADUs."),(0,n.kt)("p",null,"Reads can be issued as soon as the LUT is updated, but because an SEF Unit can delay the write\nof data to flash, when a bad block is encountered, a previously returned tentative flash address\nwill be asynchronously updated via the QoS Domain\u2019s notification function. When the read of a\ntentative flash address has been issued against an updated flash address, it will fail and needs to\nbe retried with the updated flash address. The block layer handles re-issuing the read using the\nupdated flash address. See ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/block#sec-delayedWrites"},"Delayed Writes")," for details."),(0,n.kt)("h2",{id:"io-priority"},"I/O priority"),(0,n.kt)("p",null,"The I/O priority used for reads and writes is inherited from the default weights configured for the\nQoS Domain and read FIFOs from the Virtual Device. However, when a garbage collect is active,\nthe write and copy weights are adjusted by the block layer such that the throughput of read stays\nunchanged. The priority of GC copies vs. writes is adjusted by ",(0,n.kt)("inlineCode",{parentName:"p"},"sbmAdjustIOWeights")," at the start\nof every GC-issued copy command."),(0,n.kt)("p",null,"Even though priority can be adjusted for every copy command, the current priority scheme is fixed and\nbased on the worst-case WAF, which can be calculated from the amount of over-provisioning."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"WAF <= 1/OP\n")),(0,n.kt)("p",null,"Every user write requires GC to write ",(0,n.kt)("inlineCode",{parentName:"p"},"WAF \u2212 1")," more.\nThat is, the ratio of copy to write weights has to be at least ",(0,n.kt)("inlineCode",{parentName:"p"},"WAF \u2212 1"),"\nto not be overrun by user writes. At the same time, the sum of the weights must be equal to the\ndefault program weight to not affect read die time."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"programWeight = defaultWeight \u2217 WAF \ncopyWeight = defaultWeight \u2217 (WAF \u22121) / WAF\n")),(0,n.kt)("p",null,"At the end of a GC cycle, the program weight is restored to the default weight."),(0,n.kt)("h2",{id:"sec-delayedWrites"},"Delayed Writes"),(0,n.kt)("p",null,"An SEF Unit uses delayed writes to quickly respond with a flash address but remove the burden of\nthe client handling the program size of the device. This requires the buffer lifetime to be longer\nthan completion of ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockIO"},"SEFBlockIO"),". This introduces extra overhead in the\nform of a buffer allocation and data copy. The impact of delayed writes can be eliminated by the\nclient taking responsibility for buffer management."),(0,n.kt)("p",null,"When the flag kSEFBlockIOFlagNotifyBufferRelease is set in a struct\n",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#struct-SEFMultiContext"},"SEFMultiContext")," I/O request, the caller\u2019s buffer is used for\ndelayed writes. That is, the buffer passed in must continue to be valid, even after the I/O\u2019s completion\nroutine has been called. Once the second phase of write is complete, the FTL client will receive\na struct ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#struct-SEFBlockNotify"},"SEFBlockNotify")," through the notify routine supplied in struct\n",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#struct-SEFBlockOption"},"SEFBlockOption")," when ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockInit"},"SEFBlockInit")," was\ncalled. The iov and iovcnt members describe the portion of the write buffer that is now committed\nto flash. A delayed write typically completes in milliseconds but can take tens of minutes to\ncomplete when there is insufficient data to fill the device\u2019s internal write buffer. The SDK includes\na sample buddy allocator that can allocate a large buffer with minimal fragments where portions of\nthe buffer are freed at different times."),(0,n.kt)("h3",{id:"crash-recovery"},"Crash Recovery"),(0,n.kt)("p",null,"The LUT is kept entirely in DRAM by the FTL layer. If the FTL client process were to\ncrash, the LUT and data saved on the device would be out of sync. When this happens,\n",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockInit"},"SEFBlockInit")," will fail. This can be fixed by repairing the LUT\nusing ",(0,n.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockCheck"},"SEFBlockCheck"),". Enough metadata is kept with each write to\nreconstruct the LUT, even when it is entirely lost."))}u.isMDXComponent=!0},9688:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/ftl-write-example-1-8af1a54a82bfa26f82a961adc8ab3531.png"},2447:(e,t,a)=>{a.d(t,{Z:()=>r});const r=a.p+"assets/images/ftl-write-example-2-1c16a6778808e44d0b80123438fe4e6e.png"}}]);