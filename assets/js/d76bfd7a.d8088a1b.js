"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[61],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,f=u["".concat(s,".").concat(h)]||u[h]||d[h]||o;return n?r.createElement(f,i(i({ref:t},p),{},{components:n})):r.createElement(f,i({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5134:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:2},i="Flash Translation Layer",l={unversionedId:"FTL/flash-translation-layer",id:"FTL/flash-translation-layer",title:"Flash Translation Layer",description:"chap-FlashTranslationLayer}",source:"@site/docs/FTL/flash-translation-layer.md",sourceDirName:"FTL",slug:"/FTL/flash-translation-layer",permalink:"/SEF-SDK/FTL/flash-translation-layer",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Block Layer",permalink:"/SEF-SDK/FTL/block"},next:{title:"Super Block State Management",permalink:"/SEF-SDK/FTL/superblock-management"}},s={},c=[],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"chap-FlashTranslationLayer"},"Flash Translation Layer"),(0,a.kt)("p",null,"The FTL manages the LBA lookup table (LUT). It uses the LUT to translate LBA-based block I/O\ninto SEF API flash address-based I/O on behalf of the block layer. It also processes events from the\nSEF Library to keep the LUT and Super Block state up to date as user I/O and GC I/O complete.\nThe FTL keeps the LUT in DRAM, only persisting it when the block layer is closed. The LUT uses\n8 bytes of DRAM for each LBA and is by far the largest consumer of DRAM with 2GiB required\nfor a 1TiB QoS Domain. It can be reconstructed or repaired from the written user data in the case\nof an unclean shutdown."),(0,a.kt)("p",null,"The FTL exposes functions to update and use the LUT. ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTLookupForRead()")," returns the flash\naddress for a given LBA. The call will fail if the owning Super Block is not in the Open or Closed\nstate. Additionally, it increments the reader count for the Super Block. This prevents the Super\nBlock from being released until ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTReleaseForRead()")," is called. When the Super Block is known\nto have a non-zero reader count, ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTLookup()")," can be used, which does not modify the reader\ncount or validate the Super Block is in a state where reads are allowed. Entries are placed in\nthe LUT using ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTSet()")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTUpdate()"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTSet()")," is the authoritative way to update the\nLUT. It overwrites whatever is in the LUT entry for a given LBA, whereas ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTUpdate()")," will only\nupdate when the current entry is unchanged."),(0,a.kt)("p",null,"The FTL also includes the function ",(0,a.kt)("inlineCode",{parentName:"p"},"SFTRebuildLut()")," that can be used to validate or repair the\nLUT. It can be invoked with SEF-CLI in the case of an unclean shutdown or to rebuild the LUT\nafter a domain has been restored from a backup."))}d.isMDXComponent=!0}}]);