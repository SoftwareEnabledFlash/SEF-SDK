"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[864],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(n),u=o,m=d["".concat(c,".").concat(u)]||d[u]||h[u]||r;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6891:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:4},i="Garbage Collection",l={unversionedId:"FTL/garbage-collection",id:"FTL/garbage-collection",title:"Garbage Collection",description:"chap-GarbageCollection}",source:"@site/docs/FTL/garbage-collection.md",sourceDirName:"FTL",slug:"/FTL/garbage-collection",permalink:"/SEF-SDK/FTL/garbage-collection",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docs",previous:{title:"Super Block State Management",permalink:"/SEF-SDK/FTL/superblock-management"},next:{title:"Persistence",permalink:"/SEF-SDK/FTL/persistence"}},c={},s=[],p={toc:s},d="wrapper";function h(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"chap-GarbageCollection"},"Garbage Collection"),(0,o.kt)("p",null,"Garbage collection (GC) is a single background thread that coalesces partially invalidated Super\nBlocks into a new Super Block so the partially invalid ones can be released. This makes them\navailable for future writes for the QoS Domains in the same Virtual Device. It uses the Super Block\nlayer to know which blocks are available as sources and for allocating the destination Super Block.\nThe actual data movement is performed by the SEF Unit, but the decisions of when and what\nto move are made by GC. The priority used for copy I/O is selected externally from the garbage\ncollection. At the start of each source-block copy, a notification is sent allowing the block layer\nto modify the queue-weight overrides for the copy. The garbage collection thread also has other\nrelated housekeeping functions for wear leveling, running patrols and releasing blocks marked for\nmaintenance."),(0,o.kt)("p",null,"Garbage collection is started by calling ",(0,o.kt)("inlineCode",{parentName:"p"},"GCTrigger()"),". This signals the GC thread to attempt a\ngarbage collection. It loops garbage collecting the domain until the number of allocated ADUs is\nbelow the GC trigger value. The GC trigger value is near the end of the over-provisioning set by\n",(0,o.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockConfig"},"SEFBlockConfig"),". When a patrol has been indicated for the device\nfrom the SEF Library, a call to ",(0,o.kt)("inlineCode",{parentName:"p"},"SEFCheckSuperBlock()")," is issued for each Super Block returned\nby ",(0,o.kt)("inlineCode",{parentName:"p"},"SEFGetCheckList()"),". With the collection cycle complete, the GC thread waits for the next\ntrigger."),(0,o.kt)("p",null,"Garbage collection is performed by ",(0,o.kt)("inlineCode",{parentName:"p"},"gcQoSDomain()"),". It starts by enumerating all the collectable\nblocks allocated to the QoS Domain using the function ",(0,o.kt)("inlineCode",{parentName:"p"},"SSBEnumBlocks()"),". Enumerated blocks are\nsorted by placement ID and ranked by ",(0,o.kt)("inlineCode",{parentName:"p"},"gcBuildListOfCandidates()"),". The rank of a candidate\nsource Super Block is simply the number of valid ADUs it has. The rank is hard-coded to zero for\nSuper Blocks marked for maintenance. This gives them highest priority within a placement ID.\nNext, the placement ID to collect is selected by ",(0,o.kt)("inlineCode",{parentName:"p"},"gcSelectPlacementIdToCollect()"),". For a\nplacement ID to be collected, it must have a Super Block\u2019s worth of invalid ADUs. It does not need\nto have a Super Block\u2019s worth of valid ADUs. When this occurs, the destination Super Block is\nclosed before it\u2019s full. Placement IDs with Super Blocks marked for maintenance are processed first.\nOtherwise, the placement ID with the highest ratio of invalid ADUs to allocated blocks is selected.\nDuring the process of selecting a placement ID for GC, information about the top source candidates\nis cached in the ",(0,o.kt)("inlineCode",{parentName:"p"},"sbList")," member of the ",(0,o.kt)("inlineCode",{parentName:"p"},"struct gcPidStats")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"struct gcContext"),". The\namount cached is set at compile time by the value of ",(0,o.kt)("inlineCode",{parentName:"p"},"GC_SB_LIST_SIZE"),". It is a compromise\nbetween using the most up-to-date information and the CPU required to re-enumerate the blocks in\na QoS Domain. Because the cache can be smaller than the number of source blocks required to fill\nthe destination, the ",(0,o.kt)("inlineCode",{parentName:"p"},"struct gcContext")," has a bitmap of which blocks have already been used as\na source in its member ",(0,o.kt)("inlineCode",{parentName:"p"},"srcBitmap"),". This is used to prevent a Super Block from being used twice\nfor the same destination."),(0,o.kt)("p",null,"With a placement ID selected for collection, ",(0,o.kt)("inlineCode",{parentName:"p"},"gcToASuperBlock()")," issues a nameless copy to\nthe SEF Unit for each source Super Block in rank order until the number of ADUs requested\nto copy is greater than the number of writable ADUs in the destination Super Block. As\neach nameless copy completes, it is queued to be processed after all the copies have completed\nand the destination Super Block is closed. ",(0,o.kt)("inlineCode",{parentName:"p"},"gcPostProcessCopyIOCB()")," processes the com-\npleted nameless copies with ",(0,o.kt)("inlineCode",{parentName:"p"},"SEFProcessAddressChangeRequests()"),", which will generate\n",(0,o.kt)("inlineCode",{parentName:"p"},"kAddressUpdate")," notification events for each copied ADU. The FTL\u2019s QoS Domain notification\nhandler, ",(0,o.kt)("inlineCode",{parentName:"p"},"HandleSEFNotification()"),", calls ",(0,o.kt)("inlineCode",{parentName:"p"},"SFTUpdate()")," to do a non-authoritative update of\nthe LUT so a new flash address will only be updated if unchanged since copied. This is done so that\nwhenever there is a race between an LBA being rewritten and garbage collect to update the LUT,\nthe rewrite always wins. Once ",(0,o.kt)("inlineCode",{parentName:"p"},"gcToASuperBlock()")," completes, the cycle starts again, evaluating\nthe need for GC, selecting a placement ID to collect, and performing the garbage collection."))}h.isMDXComponent=!0}}]);