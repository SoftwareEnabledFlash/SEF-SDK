"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[175],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>k});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(a),m=r,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return a?n.createElement(k,l(l({ref:t},c),{},{components:a})):n.createElement(k,l({ref:t},c))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2550:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const o={sidebar_position:3},l="Super Block State Management",i={unversionedId:"FTL/superblock-management",id:"FTL/superblock-management",title:"Super Block State Management",description:"chap-SuperBlockStateManagement}",source:"@site/docs/FTL/superblock-management.md",sourceDirName:"FTL",slug:"/FTL/superblock-management",permalink:"/SEF-SDK/FTL/superblock-management",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docs",previous:{title:"Flash Translation Layer",permalink:"/SEF-SDK/FTL/flash-translation-layer"},next:{title:"Garbage Collection",permalink:"/SEF-SDK/FTL/garbage-collection"}},s={},p=[{value:"Super Block States",id:"tab-SuperblockStates",level:4},{value:"Figure 4: Super Block State Transitions",id:"fig-SuperblockStateTransitions",level:4},{value:"Super Block Transitions",id:"tab-SuperblockTransitions",level:4}],c={toc:p},d="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(d,(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"chap-SuperBlockStateManagement"},"Super Block State Management"),(0,r.kt)("p",null,"Super block state management tracks the states of Super Blocks in use by the FTL. It mirrors\nthe state of the blocks inside the SEF Unit so decisions can be driven by information in DRAM\nrather than a constant stream of device requests. The Super Block state machine is driven by\na combination of notifications from the SEF Unit, the results of I/O operations, and operations\nperformed by garbage collection (GC)."),(0,r.kt)("p",null,"The state of each Super Block is tracked in an array indexed by Super Block ID. As a result,\nmemory consumption is affected by the size of the Virtual Device, 16 bytes per Super Block. A\nbitmap is allocated to track which ADUs are valid, requiring ",(0,r.kt)("inlineCode",{parentName:"p"},"8+super_block_capacity_adus/8"),"\nbytes for each Super Block assigned to the QoS Domain. The bits are set and cleared using\n",(0,r.kt)("inlineCode",{parentName:"p"},"SSBSetAduValid()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBClearAduValid()"),", respectively. A snapshot of the bits is read\nusing ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBCopyValidBits()"),". As an example, for a 1TiB Virtual Device with 64Kibi ADUs per\nSuper Block and a maximally sized QoS Domain, the memory required is 64KiB for an empty QoS\nDomain and just over 32MiB when it is full."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(6925).Z,width:"1823",height:"657"})),(0,r.kt)("p",null,"Super blocks can be in 1 of 7 states. The Super Block states are described\nin ",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/superblock-management#tab-SuperblockStates"},"Super Block States"),", and transitions are shown in Figure ",(0,r.kt)("a",{parentName:"p",href:"#fig-SuperblockStateTransitions"},"4"),"."),(0,r.kt)("h4",{id:"tab-SuperblockStates"},"Super Block States"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"State"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Deleted"),(0,r.kt)("td",{parentName:"tr",align:null},"Not in use by the QoS Domain.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Allocated"),(0,r.kt)("td",{parentName:"tr",align:null},"Owned by the QoS Domain but is not yet available for read or write. A Super Block that is the destination for nameless copy is in this state until it is filled.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Open"),(0,r.kt)("td",{parentName:"tr",align:null},"Mirrors the open state in the device. The Super Block is available for read and write.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Closed"),(0,r.kt)("td",{parentName:"tr",align:null},"Mirrors the closed state in the device. The Super Block is available only for read.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Busy"),(0,r.kt)("td",{parentName:"tr",align:null},"Valid ADU count is zero, but there are still reads in-flight. No new reads are allowed.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Empty"),(0,r.kt)("td",{parentName:"tr",align:null},"Valid ADU count is zero and the Super Block is being released back to the Virtual Device Super Block pool.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Meta"),(0,r.kt)("td",{parentName:"tr",align:null},"Holds FTL data, not user data. These are allocated/released when the block layer shuts down and persists the LUT.")))),(0,r.kt)("h4",{id:"fig-SuperblockStateTransitions"},"Figure 4: Super Block State Transitions"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Super Block State Transitions",src:a(668).Z,width:"774",height:"588"})),(0,r.kt)("p",null,"The state value also contains a reader count. When a read is issued against a Super\nBlock, that count is incremented by ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBMarkBusy()")," to prevent it from being deleted.\n",(0,r.kt)("inlineCode",{parentName:"p"},"SSBMarkNotBusy()")," decrements the count once the read completes. There is also a reference\ncount that is incremented by ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBSetAduValid()")," for each valid ADU and decremented by\n",(0,r.kt)("inlineCode",{parentName:"p"},"SSBClearAduValid()")," for each invalid ADU. Two extra counts are held for the allocated and\nopen states. The extra counts are removed by calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBRemoveRef()")," and by ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBClosed()"),".\n",(0,r.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/superblock-management#tab-SuperblockTransitions"},"Super Block Transitions")," provides additional detail on when a Super\nBlock will transition to a new state."),(0,r.kt)("h4",{id:"tab-SuperblockTransitions"},"Super Block Transitions"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Transition"),(0,r.kt)("th",{parentName:"tr",align:null},"Triggers"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Deleted to Allocated"),(0,r.kt)("td",{parentName:"tr",align:null},"There are two events that cause this transition: when a flash address is returned from a write for a Super Block in the deleted state and when garbage collection allocates a destination Super Block.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Allocated to Open"),(0,r.kt)("td",{parentName:"tr",align:null},"When a flash address is returned from a write transitioning the Super Block to the allocated state, it moves immediately to the open state.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Allocated/Open to Closed"),(0,r.kt)("td",{parentName:"tr",align:null},"A close notification from the device is processed.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Closed to Busy"),(0,r.kt)("td",{parentName:"tr",align:null},"The reference count for the Super Block has become zero, and the active reader count is non-zero. The reference count is decremented when an LBA is rewritten, GC moves an LBA, or the Super Block transitions out of Open.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Closed to Empty"),(0,r.kt)("td",{parentName:"tr",align:null},"The reference count for the Super Block has become zero, and the active reader count is zero The reference count is decremented when an LBA is rewritten, GC moves an LBA, or the Super Block transitions out of Open")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Empty to Deleted"),(0,r.kt)("td",{parentName:"tr",align:null},"The release of the Super Block is issued and moves immediately to Deleted.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Meta to/from Deleted"),(0,r.kt)("td",{parentName:"tr",align:null},"At FTL shutdown, the persistence layer has allocated space to save the LUT and has released the old LUT back to the Virtual Device Super Block pool.")))),(0,r.kt)("p",null,"Super blocks are released asynchronously as they become empty. This can be prevented by marking\na block as busy with ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBMarkBusy()"),". The returned instance ID can be used to verify the block\nhasn\u2019t been released and reallocated between enumeration with ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBEnumBlocks()")," or other calls\nto ",(0,r.kt)("inlineCode",{parentName:"p"},"SSBMarkBusy()"),"."))}u.isMDXComponent=!0},6925:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/formula-fe668278557ced761ac8e2677b18a803.png"},668:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/superblock-state-transitions-d7b466c29dc0d41e5a8a07d13aee52ef.png"}}]);