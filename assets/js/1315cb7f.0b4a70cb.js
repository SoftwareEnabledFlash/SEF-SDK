"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[944],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>f});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=d(t),m=i,f=p["".concat(s,".").concat(m)]||p[m]||c[m]||r;return t?a.createElement(f,o(o({ref:n},u),{},{components:t})):a.createElement(f,o({ref:n},u))}));function f(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=t[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4511:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=t(7462),i=(t(7294),t(3905));const r={sidebar_position:0},o="QEMU",l={unversionedId:"QEMU/overview",id:"QEMU/overview",title:"QEMU",description:"chap-qemu}",source:"@site/docs/QEMU/overview.md",sourceDirName:"QEMU",slug:"/QEMU/overview",permalink:"/SEF-SDK/QEMU/overview",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"docs",previous:{title:"Flexible I/O Tester (FIO)",permalink:"/SEF-SDK/FIO/overview"},next:{title:"NVMe-CLI",permalink:"/SEF-SDK/NVMe-CLI/overview"}},s={},d=[{value:"SEF-Backed Virtual Driver",id:"subsec-qemuExVD",level:2},{value:"SEF-Backed ZNS Device",id:"subsec-qemuExZNS",level:2},{value:"SEF-specific ZNS Device Options",id:"tab-qemuZnsOptions",level:4},{value:"SEF-Backed NVMe Device",id:"subsec-qemuNVMe",level:2},{value:"SEF-specific NVMe Device Options",id:"tab-qemuNvmeOptions",level:4}],u={toc:d},p="wrapper";function c(e){let{components:n,...t}=e;return(0,i.kt)(p,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"chap-qemu"},"QEMU"),(0,i.kt)("p",null,"The Software-Enabled Flash\u2122\ufe0f (SEF) Software Development Kit (SDK) includes QEMU storage\ndevices that allow non-SEF enabled software to be tested with an SEF Unit. The storage devices\ntranslate block APIs into SEF commands storing the data in an SEF Unit. The storage devices\nincluded are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("a",{parentName:"li",href:"#subsec-qemuExVD"},"SEF-Backed Virtual Driver")),(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("a",{parentName:"li",href:"#subsec-qemuNVMe"},"SEF-Backed NVMe Driver with FDP support")),(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("a",{parentName:"li",href:"#subsec-qemuExZNS"},"SEF-Backed ZNS Device"))),(0,i.kt)("p",null,"To use them, an SEF Unit and SEF QoS Domain are supplied as parameters. The storage devices\nthen present a block device to the QEMU guest based on the SEF QoS Domain\u2019s configuration. See\neach sub-section for details on how to use them."),(0,i.kt)("h2",{id:"subsec-qemuExVD"},"SEF-Backed Virtual Driver"),(0,i.kt)("p",null,"The SEF patches for QEMU add support for a virtual driver called sef-aio. Instead of using a file for\na backing store, it uses an SEF QoS Domain. The QoS Domain must be unconfigured or configured\nas an SEF Block FTL domain. An unconfigured domain will be auto configured as an SEF Block\nFTL domain when it\u2019s mounted. The file option selects the unit and QoS Domain and has the\nfollowing format: ",(0,i.kt)("inlineCode",{parentName:"p"},"file=<unit>:<domain>"),". Below is an example of a QEMU command line with\noptions for an SEF Virtual Device on SEF Unit 0 and QoS Domain 3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo qemu -name sefAio -m 4G -smp 8 -enable-kvm                                              \\\n  -drive file=system-debian.qcow2,cache=none,format=qcow2,if=virtio                           \\\n  -netdev user,id=vnet,hostfwd=tcp:127.0.0.1:2222-:22                                         \\\n  -device virtio-net-pci,netdev=vnet -nographic                                               \\\n  -display none -cpu host                                                                     \\\n  -drive driver=sef-aio,file=0:3,cache=none,if=virtio\n")),(0,i.kt)("p",null,"To verify the virtual drive is present, run the command lsblk. In this case, it\u2019s the device\nvdb."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo lsblk\n\nNAME     MAJ:MIN RM      SIZE RO TYPE MOUNTPOINT\nfd0         2:0      1      4K   0 disk\nsr0       11:0       1 1024M     0 rom\nvda      254:0       0   100G    0 disk\n+-vda1 254:1         0    96G    0 part /\n+-vda2 254:2         0      1K   0 part\n+-vda5 254:5         0      4G   0 part [SWAP]\nvdb      254:16      0   4.3G    0 disk\n")),(0,i.kt)("p",null,"FIO can be used for testing the device from within the virtual machine. Below is an example that\nrandomly reads and writes to the device."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo fio -ioengine=libaio -filename=/dev/vdb -name=rw -randrw\n")),(0,i.kt)("h2",{id:"subsec-qemuExZNS"},"SEF-Backed ZNS Device"),(0,i.kt)("p",null,"The standard NVMe device for QEMU supports ZNS. Using it requires that the guest\nOS has a Linux kernel of 5.9 or later. It\u2019s enabled with the option ",(0,i.kt)("inlineCode",{parentName:"p"},"zoned=true"),". The\nSEF patches for QEMU add support for using an SEF QoS Domain as a backing store.\n",(0,i.kt)("a",{parentName:"p",href:"#tab-qemuZnsOptions"},"SEF-specific ZNS Device Options")," shows the SEF-specific options. The\nSEF QoS Domain used must be unconfigured or configured as an SEF ZNS domain. An unconfigured\ndomain will be auto configured as an SEF ZNS domain."),(0,i.kt)("h4",{id:"tab-qemuZnsOptions"},"SEF-specific ZNS Device Options"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Option"),(0,i.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sef"),(0,i.kt)("td",{parentName:"tr",align:null},"false"),(0,i.kt)("td",{parentName:"tr",align:null},"If true, switches from a file as a backing store to an SEF QoS Domain. In this mode, a zone is an SEF Super Block, which dictates the default zone. Setting the zone size smaller is supported but will waste space.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sef_unit"),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"Unit number of the SEF Unit to use as the backing store.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sef_qos_domain"),(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"QoS Domain ID to use as the backing store.")))),(0,i.kt)("p",null,"Below is an example of a QEMU command line with options for an SEF-backed ZNS device on QoS\nDomain 3. Although unused, it\u2019s still required to supply a valid backing file, even if it's zero-sized.\nThe example is using the default of 0 for the SEF Unit number and explicitly configuring QoS\nDomain 3."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo qemu -name sefZns -m 4G -smp 8 -enable-kvm                                                \\\n  -drive file=system-debian.qcow2,cache=none,format=qcow2,if=virtio                             \\\n  -netdev user,id=vnet,hostfwd=tcp:127.0.0.1:2222-:22                                           \\\n  -device virtio-net-pci,netdev=vnet -nographic                                                 \\\n  -display none -cpu host                                                                       \\\n  -drive if=none,id=nvme1,file=nvme3.raw,format=raw                                             \\\n  -device nvme,serial=654321                                                                    \\\n  -device nvme-ns,drive=nvme1,nsid=1,sef=true,zoned=true,                                       \\\n      sef_qos_domain=3\n")),(0,i.kt)("p",null,"To verify the ZNS device is present, run the command ",(0,i.kt)("inlineCode",{parentName:"p"},"lsblk -z"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo lsblk -z\n\nNAME        ZONED\nfd0         none\nsr0         none\nvda         none\n+-vda1      none\n+-vda2      none\n+-vda5      none\nnvme0n1 host-managed\n")),(0,i.kt)("p",null,"The indication \u201chost managed\u201d tells you that device nvme0n1 is a ZNS device."),(0,i.kt)("p",null,"FIO can be used for testing ZNS devices from within the virtual machine. Below is an example\nthat randomly reads and writes 8 gigabytes of data using 128k I/O requests. The request types are\nevenly split between reads and writes, yielding 4 gigabytes of reads and 4 gigabytes of writes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo fio --aux-path=/tmp --allow_file_create=0 --name=job1         \\\n  --filename=/dev/nvme0n1 --rw=randrw --direct=1                    \\\n  --zonemode=zbd --bs=128k --size=8G\n")),(0,i.kt)("p",null,"When run only once, it will not fill the device since half of the size is used for reads, and size\nwill be rounded down to the device size if larger. To see how much data has been written, run\n",(0,i.kt)("inlineCode",{parentName:"p"},"blkzone report /dev/nvme0n1")," for the write pointer value of each zone. By running the fio\njob more than once, it will eventually fill a zone, which will then be reset/erased to allow for more\nwrites."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo blkzone report /dev/nvme0n1 | head -2\n\n  start: 0x000000000, len 0x010000, cap 0x010000, wptr 0x009800\n          reset:0 non-seq:0, zcond: 2(oi) [type: 2(SEQ_WRITE_REQUIRED)]\n  start: 0x000010000, len 0x010000, cap 0x010000, wptr 0x00aa00\n          reset:0 non-seq:0, zcond: 2(oi) [type: 2(SEQ_WRITE_REQUIRED)]\n")),(0,i.kt)("h2",{id:"subsec-qemuNVMe"},"SEF-Backed NVMe Device"),(0,i.kt)("p",null,"The SEF patches for QEMU add support for using an SEF QoS Domain as a backing store for a\nQEMU NVMe device. ",(0,i.kt)("a",{parentName:"p",href:"#tab-qemuNvmeOptions"},"SEF-specific NVMe Device Options")," shows the\nSEF-specific options. The QoS Domain must be unconfigured or configured as an SEF Block FTL\ndomain. An unconfigured domain will be auto configured as an SEF Block FTL domain when it\u2019s\nmounted."),(0,i.kt)("h4",{id:"tab-qemuNvmeOptions"},"SEF-specific NVMe Device Options"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Option"),(0,i.kt)("th",{parentName:"tr",align:null},"Default Value"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sef"),(0,i.kt)("td",{parentName:"tr",align:null},"false"),(0,i.kt)("td",{parentName:"tr",align:null},"If true, switches from a file as a backing store to an SEF QoS Domain. In this mode, the SEF reference FTL is used to provide block I/O for the QEMU NVMe device.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sef_unit"),(0,i.kt)("td",{parentName:"tr",align:null},"0"),(0,i.kt)("td",{parentName:"tr",align:null},"Unit number of the SEF Unit to use as the backing store.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sef_qos_domain"),(0,i.kt)("td",{parentName:"tr",align:null},"2"),(0,i.kt)("td",{parentName:"tr",align:null},"QoS Domain ID to use as the backing store.")))),(0,i.kt)("p",null,"Below is an example of a QEMU command line with options for an SEF-backed NVMe device\non QoS Domain 2. Although unused, it\u2019s still required to supply a valid backing file, even if it\u2019s\nzero-sized. The example is using the default of 0 for the SEF Unit number and the default of 2 for\nthe QoS Domain."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo qemu -name sefNvme -m 4G -smp 8 -enable-kvm                                     \\\n  -drive file=system-debian.qcow2,cache=none,format=qcow2,if=virtio                   \\\n  -netdev user,id=vnet,hostfwd=tcp:127.0.0.1:2222-:22                                 \\\n  -device virtio-net-pci,netdev=vnet -nographic                                       \\\n  -display none -cpu host                                                             \\\n  -drive if=none,id=nvme1,file=nvme2.raw,format=raw                                   \\\n  -device nvme,serial=123456                                                          \\\n  -device nvme-ns,drive=nvme1,nsid=1,sef=true\n")),(0,i.kt)("p",null,"To verify the virtual drive is present, run the command ",(0,i.kt)("inlineCode",{parentName:"p"},"lsblk"),". In this case, it\u2019s the device\nvdb."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo lsblk\n\nNAME     MAJ:MIN RM          SIZE RO TYPE MOUNTPOINT\nfd0         2:0      1         4K    0 disk\nsr0       11:0       1 1024M         0 rom\nvda      254:0       0       100G    0 disk\n+-vda1 254:1         0        96G    0 part /\n+-vda2 254:2         0         1K    0 part\n+-vda5 254:5         0         4G    0 part [SWAP]\nnvme0n1 259:0            0    4.3G    0 disk\n")),(0,i.kt)("p",null,"FIO can be used for testing the device from within the virtual machine. Below is an example that\nrandomly reads and writes to the device."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"$sudo fio -ioengine=libaio -filename=/dev/nvme0n1 -name=rw -randrw\n")))}c.isMDXComponent=!0}}]);