"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[17],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>y});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)r=i[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(r),h=a,y=u["".concat(l,".").concat(h)]||u[h]||p[h]||i;return r?n.createElement(y,o(o({ref:t},d),{},{components:r})):n.createElement(y,o({ref:t},d))}));function y(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},6012:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=r(7462),a=(r(7294),r(3905));const i={sidebar_position:0},o="SEF Library",s={unversionedId:"Library/overview",id:"Library/overview",title:"SEF Library",description:"chap-SEFLibrary}",source:"@site/docs/Library/overview.md",sourceDirName:"Library",slug:"/Library/overview",permalink:"/SEF-SDK/Library/overview",draft:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{sidebar_position:0},sidebar:"docs",previous:{title:"SEF Driver",permalink:"/SEF-SDK/Driver/overview"},next:{title:"SEF Reference Flash Translation Layer (FTL)",permalink:"/SEF-SDK/FTL/overview"}},l={},c=[{value:"Design Environment",id:"design-environment",level:2},{value:"Design Strategy",id:"design-strategy",level:2},{value:"Threading Model",id:"threading-model",level:2}],d={toc:c},u="wrapper";function p(e){let{components:t,...r}=e;return(0,a.kt)(u,(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"chap-SEFLibrary"},"SEF Library"),(0,a.kt)("h2",{id:"design-environment"},"Design Environment"),(0,a.kt)("p",null,"The Software-Enabled Flash\u2122\ufe0f (SEF) Library runs on a Linux\u2122\ufe0f host. It only supports user\nmode and does not support forked processes. The SEF Library API is defined by SEFAPI.h and\nimplemented in libsef.so. It converts interface calls into NVMe SEF command set commands and\nsubmits them to the SEF kernel driver."),(0,a.kt)("h2",{id:"design-strategy"},"Design Strategy"),(0,a.kt)("p",null,"The SEF Library makes every effort to execute what it's asked to do. It does not enforce any\npolicies. Limits are the responsibility of the caller. I/O requests that are larger than the device's\nmax data transfer size are split up by the library in a way to simulate a single device request. For\nsplit writes and copies, requests for flash addresses are serialized to keep the addresses sequential\nwhen possible. The write commands and split reads run concurrently with no limit placed on how\nmany requests are generated. Large I/Os and large I/O depths can overwhelm the device queues,\ncausing the driver to reject requests. These are automatically retried after a delay. This makes the\nAPI simple to use but can lead to significant latency and may render weighted fair queueing I/O\npolicies ineffective."),(0,a.kt)("h2",{id:"threading-model"},"Threading Model"),(0,a.kt)("p",null,"A threading model was chosen that prevents lost I/O completion and deadlock. I/O uring is used to\nsend all asynchronous requests to the SEF driver. The submitting and completion of asynchronous\nSEF driver requests is handled by an internal, statically sized thread pool based on the number of\nCPUs. When possible, synchronous requests use ioctl() issued from the caller's thread. Pair\ncommands, which can't use ioctl(), use a dedicated thread. This design allows the lifetime of\nthe caller's thread to be independent of the I/O it issues and prevents deadlock when a synchronous\nAPI call is made from an asynchronous I/O completion callback. New I/O issued from a completion\nroutine will be submitted using the completion thread, avoiding the overhead of switching to an\nI/O thread. There are two additional threads started by the SEF Library to handle notifications.\nOne handles udev events sent by the SEF driver, and the other monitors closing Super Blocks and\nissues a close notification once all write I/O has completed."),(0,a.kt)("p",null,"Use of the SEF API will never internally deadlock, but issuing a synchronous request or waiting for\na resource owned by another completion may add latency to any I/O issued by the blocked thread.\nDeadlock may still occur externally if a completion routine blocks on resources that require another\ncompletion routine to execute."))}p.isMDXComponent=!0}}]);