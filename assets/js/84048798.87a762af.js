"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[122],{3905:(t,e,a)=>{a.d(e,{Zo:()=>p,kt:()=>s});var n=a(7294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function o(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function i(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var k=n.createContext({}),u=function(t){var e=n.useContext(k),a=e;return t&&(a="function"==typeof t?t(e):o(o({},e),t)),a},p=function(t){var e=u(t.components);return n.createElement(k.Provider,{value:e},t.children)},m="mdxType",d={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},c=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,k=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),m=u(a),c=l,s=m["".concat(k,".").concat(c)]||m[c]||d[c]||r;return a?n.createElement(s,o(o({ref:e},p),{},{components:a})):n.createElement(s,o({ref:e},p))}));function s(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,o=new Array(r);o[0]=c;var i={};for(var k in e)hasOwnProperty.call(e,k)&&(i[k]=e[k]);i.originalType=t,i[m]="string"==typeof t?t:l,o[1]=i;for(var u=2;u<r;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},1112:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>k,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var n=a(7462),l=(a(7294),a(3905));const r={sidebar_position:8},o="SEF FTL Public API",i={unversionedId:"FTL/ftl-api",id:"FTL/ftl-api",title:"SEF FTL Public API",description:"SEFBlockIOType",source:"@site/docs/FTL/ftl-api.md",sourceDirName:"FTL",slug:"/FTL/ftl-api",permalink:"/SEF-SDK/FTL/ftl-api",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"docs",previous:{title:"Logging",permalink:"/SEF-SDK/FTL/logging"},next:{title:"Command Line Interface (CLI)",permalink:"/SEF-SDK/CLI/overview"}},k={},u=[{value:"SEFBlockIOType",id:"enum-SEFBlockIOType",level:2},{value:"Members of SEFBlockIOType",id:"members-of-sefblockiotype",level:4},{value:"SEFBlockIOFlags",id:"enum-SEFBlockIOFlags",level:2},{value:"Members of SEFBlockIOFlags",id:"members-of-sefblockioflags",level:4},{value:"SEFBlockNotifyType",id:"enum-SEFBlockNotifyType",level:2},{value:"Members of SEFBlockNotifyType",id:"members-of-sefblocknotifytype",level:4},{value:"SEFBlockConfig",id:"function-SEFBlockConfig",level:2},{value:"Parameters of SEFBlockConfig",id:"parameters-of-sefblockconfig",level:4},{value:"Return value of SEFBlockConfig",id:"return-value-of-sefblockconfig",level:4},{value:"Return values of SEFBlockConfig",id:"return-values-of-sefblockconfig",level:4},{value:"SEFBlockInit",id:"function-SEFBlockInit",level:2},{value:"Parameters of SEFBlockInit",id:"parameters-of-sefblockinit",level:4},{value:"Return value of SEFBlockInit",id:"return-value-of-sefblockinit",level:4},{value:"Return values of SEFBlockInit",id:"return-values-of-sefblockinit",level:4},{value:"SEFBlockMount",id:"function-SEFBlockMount",level:2},{value:"Parameters of SEFBlockMount",id:"parameters-of-sefblockmount",level:4},{value:"Return value of SEFBlockMount",id:"return-value-of-sefblockmount",level:4},{value:"SEFBlockGetInfo",id:"function-SEFBlockGetInfo",level:2},{value:"Parameters of SEFBlockGetInfo",id:"parameters-of-sefblockgetinfo",level:4},{value:"SEFBlockIO",id:"function-SEFBlockIO",level:2},{value:"Parameters of SEFBlockIO",id:"parameters-of-sefblockio",level:4},{value:"Return value of SEFBlockIO",id:"return-value-of-sefblockio",level:4},{value:"Return values of SEFBlockIO",id:"return-values-of-sefblockio",level:4},{value:"SEFBlockTrim",id:"function-SEFBlockTrim",level:2},{value:"Parameters of SEFBlockTrim",id:"parameters-of-sefblocktrim",level:4},{value:"Return value of SEFBlockTrim",id:"return-value-of-sefblocktrim",level:4},{value:"Return values of SEFBlockTrim",id:"return-values-of-sefblocktrim",level:4},{value:"SEFBlockCancel",id:"function-SEFBlockCancel",level:2},{value:"Parameters of SEFBlockCancel",id:"parameters-of-sefblockcancel",level:4},{value:"Return value of SEFBlockCancel",id:"return-value-of-sefblockcancel",level:4},{value:"Return values of SEFBlockCancel",id:"return-values-of-sefblockcancel",level:4},{value:"SEFBlockCheck",id:"function-SEFBlockCheck",level:2},{value:"Parameters of SEFBlockCheck",id:"parameters-of-sefblockcheck",level:4},{value:"Return value of SEFBlockCheck",id:"return-value-of-sefblockcheck",level:4},{value:"SEFBlockCleanup",id:"function-SEFBlockCleanup",level:2},{value:"Parameters of SEFBlockCleanup",id:"parameters-of-sefblockcleanup",level:4},{value:"Return value of SEFBlockCleanup",id:"return-value-of-sefblockcleanup",level:4},{value:"Return values of SEFBlockCleanup",id:"return-values-of-sefblockcleanup",level:4},{value:"SEFMultiContext",id:"struct-SEFMultiContext",level:2},{value:"Members of SEFMultiContext",id:"members-of-sefmulticontext",level:4},{value:"SEFBlockNotify",id:"struct-SEFBlockNotify",level:2},{value:"Members of SEFBlockNotify",id:"members-of-sefblocknotify",level:4},{value:"SEFBlockOption",id:"struct-SEFBlockOption",level:2},{value:"Members of SEFBlockOption",id:"members-of-sefblockoption",level:4},{value:"SEFBlockConfig",id:"struct-SEFBlockConfig",level:2},{value:"Members of SEFBlockConfig",id:"members-of-sefblockconfig",level:4},{value:"SEFBlockInfo",id:"struct-SEFBlockInfo",level:2},{value:"Members of SEFBlockInfo",id:"members-of-sefblockinfo",level:4}],p={toc:u},m="wrapper";function d(t){let{components:e,...a}=t;return(0,l.kt)(m,(0,n.Z)({},p,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"sef-ftl-public-api"},"SEF FTL Public API"),(0,l.kt)("h2",{id:"enum-SEFBlockIOType"},"SEFBlockIOType"),(0,l.kt)("p",null,"Type of i/o in a SEFMultiContext. "),(0,l.kt)("h4",{id:"members-of-sefblockiotype"},"Members of SEFBlockIOType"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Member"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"kSEFRead"),(0,l.kt)("td",{parentName:"tr",align:null},"Performs a read operation")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"kSEFWrite"),(0,l.kt)("td",{parentName:"tr",align:null},"Performs a write operation")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"enum-SEFBlockIOFlags"},"SEFBlockIOFlags"),(0,l.kt)("p",null,"I/O flags in a SEFMultiContext. "),(0,l.kt)("h4",{id:"members-of-sefblockioflags"},"Members of SEFBlockIOFlags"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Member"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"kSEFBlockIOFlagNotifyBufferRelease"),(0,l.kt)("td",{parentName:"tr",align:null},"Buffer lifetime is controlled by caller")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"enum-SEFBlockNotifyType"},"SEFBlockNotifyType"),(0,l.kt)("p",null,"Event types for SEFBlockNotify. "),(0,l.kt)("h4",{id:"members-of-sefblocknotifytype"},"Members of SEFBlockNotifyType"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Member"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"kSefBlockNotifyGCDown"),(0,l.kt)("td",{parentName:"tr",align:null},"GC can no longer make progress, write I/O will fail")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"kSefBlockNotifyBufferRelease"),(0,l.kt)("td",{parentName:"tr",align:null},"A portion of an I/O buffer can be released")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockConfig"},"SEFBlockConfig"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockConfig(uint16_t SEFUnitIndex, struct SEFQoSDomainID QoSDomainID, struct SEFBlockConfig *config)\n")),(0,l.kt)("p",null,"This function is used to configure the SEF Block Module. "),(0,l.kt)("p",null,"It configures freshly created QoS domains so they can used as a SEF Block Module domain. It sets the number of QoS domains and the amount of over provisioning to use. Once these values are set, they cannot be changed without erasing or recreating the QoS domains."),(0,l.kt)("p",null,"A QoS domain must be configured as a SEF Block Module domain before calling SEFBlockModuleInit()."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockInit"},"SEFBlockInit()")," "),(0,l.kt)("h4",{id:"parameters-of-sefblockconfig"},"Parameters of SEFBlockConfig"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"SEFUnitIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The index of the SEF Unit; the index is zero-based")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"QoS Domain ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#struct-SEFBlockConfig"},"struct SEFBlockConfig","*")),(0,l.kt)("td",{parentName:"tr",align:null},"config"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to an instance of SEFBlockConfig, for config settings")))),(0,l.kt)("h4",{id:"return-value-of-sefblockconfig"},"Return value of SEFBlockConfig"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("h4",{id:"return-values-of-sefblockconfig"},"Return values of SEFBlockConfig"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EINVAL"),(0,l.kt)("td",{parentName:"tr",align:null},"Invalid over provisioning percentage")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EEXIST"),(0,l.kt)("td",{parentName:"tr",align:null},"The device is already configured, can not reconfigure a pre-configured device")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EBADF"),(0,l.kt)("td",{parentName:"tr",align:null},"The block module was not shutdown cleanly; Consider running Check Disk")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockInit"},"SEFBlockInit"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockInit(uint16_t SEFUnitIndex, struct SEFQoSDomainID QoSDomainID, struct SEFBlockOption *options, SEFBlockHandle *blockHandle)\n")),(0,l.kt)("p",null,"This function is used to get a SEFBlockModuleHandle for issuing I/O. "),(0,l.kt)("p",null,"The QoS domain must be configured as a SEF Block Module domain using SEFBlockConfig() before calling SEFBlockInit(). Configuration only needs to be done once."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockConfig"},"SEFBlockConfig()")," "),(0,l.kt)("h4",{id:"parameters-of-sefblockinit"},"Parameters of SEFBlockInit"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"SEFUnitIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"The index of the SEF Unit; the index is zero-based")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFQoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"QoSDomainID"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"QoS Domain ID")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#struct-SEFBlockOption"},"struct SEFBlockOption","*")),(0,l.kt)("td",{parentName:"tr",align:null},"options"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to an instance of SEFBlockOption, for runtime options")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockHandle ","*"),(0,l.kt)("td",{parentName:"tr",align:null},"blockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to the SEF Block handle to be used for access to the block instance")))),(0,l.kt)("h4",{id:"return-value-of-sefblockinit"},"Return value of SEFBlockInit"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("h4",{id:"return-values-of-sefblockinit"},"Return values of SEFBlockInit"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EINVAL"),(0,l.kt)("td",{parentName:"tr",align:null},"Invalid log level")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EBADF"),(0,l.kt)("td",{parentName:"tr",align:null},"The block module was not shutdown cleanly; Consider running Check Disk")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-ENOENT"),(0,l.kt)("td",{parentName:"tr",align:null},"Block layer has not been configured with SEFBlockConfig()")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockMount"},"SEFBlockMount"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockMount(SEFBlockHandle blockHandle)\n")),(0,l.kt)("p",null,"This function mounts the FTL configured domain if not already mounted. "),(0,l.kt)("p",null,"It's required to be called before calling SEFBlockIO() when SEFBlockInit() was called with the option delayMount set to true. Calling it when it's not required has no effect."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"See Also:")," ",(0,l.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockInit"},"SEFBlockInit()"),", ",(0,l.kt)("a",{parentName:"p",href:"/SEF-SDK/FTL/ftl-api#function-SEFBlockIO"}," SEFBlockIO()")," "),(0,l.kt)("h4",{id:"parameters-of-sefblockmount"},"Parameters of SEFBlockMount"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"blockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"SEF Block handle to be used for access to the block instance")))),(0,l.kt)("h4",{id:"return-value-of-sefblockmount"},"Return value of SEFBlockMount"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockGetInfo"},"SEFBlockGetInfo"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"void SEFBlockGetInfo(SEFBlockHandle blockHandle, struct SEFBlockInfo *info)\n")),(0,l.kt)("p",null,"This function returns size information about a block device. "),(0,l.kt)("p",null,"The function requires the block layer to be initialized before it is called."),(0,l.kt)("h4",{id:"parameters-of-sefblockgetinfo"},"Parameters of SEFBlockGetInfo"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"blockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"SEF Block handle to be used for access to the block instance")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#struct-SEFBlockInfo"},"struct SEFBlockInfo","*")),(0,l.kt)("td",{parentName:"tr",align:null},"info"),(0,l.kt)("td",{parentName:"tr",align:null},"Out"),(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockInfo struct to fill with data")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockIO"},"SEFBlockIO"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockIO(struct SEFMultiContext *context)\n")),(0,l.kt)("p",null,"This function is used to perform I/O commands. "),(0,l.kt)("h4",{id:"parameters-of-sefblockio"},"Parameters of SEFBlockIO"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#struct-SEFMultiContext"},"struct SEFMultiContext","*")),(0,l.kt)("td",{parentName:"tr",align:null},"context"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to an instance of SEFMultiContext")))),(0,l.kt)("h4",{id:"return-value-of-sefblockio"},"Return value of SEFBlockIO"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("h4",{id:"return-values-of-sefblockio"},"Return values of SEFBlockIO"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EINVAL"),(0,l.kt)("td",{parentName:"tr",align:null},"The input parameters are invalid; either Scatter gather list is too small or I/O exceeds the device capacity")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-ENOPROTOOPT"),(0,l.kt)("td",{parentName:"tr",align:null},"FTL is either not initialized or shutting down, failing I/O")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EBUSY"),(0,l.kt)("td",{parentName:"tr",align:null},"I/o context p appears to be in use")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-ECANCELED"),(0,l.kt)("td",{parentName:"tr",align:null},"GC shutdown, inflight writes canceled")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockTrim"},"SEFBlockTrim"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockTrim(SEFBlockHandle blockHandle, int64_t lba, int32_t lbc)\n")),(0,l.kt)("p",null,"This function is used to discard or TRIM LBAs that are no longer needed by the application. "),(0,l.kt)("h4",{id:"parameters-of-sefblocktrim"},"Parameters of SEFBlockTrim"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"blockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"SEF Block handle to be used for access to the block instance")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int64","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"lba"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Logical block address")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int32","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"lbc"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Logical block count")))),(0,l.kt)("h4",{id:"return-value-of-sefblocktrim"},"Return value of SEFBlockTrim"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("h4",{id:"return-values-of-sefblocktrim"},"Return values of SEFBlockTrim"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-ENOTBLK"),(0,l.kt)("td",{parentName:"tr",align:null},"The Block context is not valid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EINVAL"),(0,l.kt)("td",{parentName:"tr",align:null},"The LBA or LBC is not valid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-EIO"),(0,l.kt)("td",{parentName:"tr",align:null},"Was unable to trim; the Info would indicate LBC that wasn't completed")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockCancel"},"SEFBlockCancel"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockCancel(struct SEFMultiContext *context)\n")),(0,l.kt)("p",null,"Requests the passed in I/O be canceled. "),(0,l.kt)("p",null,"It's the caller's responsibility to ensure that the context is valid for the duration of the call. Because of internal race conditions, the call may fail and yet still cancel the I/O. Also possible is the function returns success, yet the I/O completes without error instead of a canceled I/O error."),(0,l.kt)("h4",{id:"parameters-of-sefblockcancel"},"Parameters of SEFBlockCancel"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#struct-SEFMultiContext"},"struct SEFMultiContext","*")),(0,l.kt)("td",{parentName:"tr",align:null},"context"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"a pointer to an instance of SEFMultiContext")))),(0,l.kt)("h4",{id:"return-value-of-sefblockcancel"},"Return value of SEFBlockCancel"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("h4",{id:"return-values-of-sefblockcancel"},"Return values of SEFBlockCancel"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-ENOENT"),(0,l.kt)("td",{parentName:"tr",align:null},"The I/O was not found in the any queues")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockCheck"},"SEFBlockCheck"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockCheck(SEFBlockHandle blockHandle, int shouldRepair)\n")),(0,l.kt)("p",null,"This function is used to check if the stored data and metadata match. "),(0,l.kt)("p",null,"Moreover, it is capable of repairing the device. To create a blockHandle for a device that won't mount, call SEFBlockInit() with the delayMount option set to true."),(0,l.kt)("h4",{id:"parameters-of-sefblockcheck"},"Parameters of SEFBlockCheck"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"blockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to the SEF Block handle to be used for access to the block instance.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"shouldRepair"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"Should the block module be repaired if it is faulty? 1 denotes true")))),(0,l.kt)("h4",{id:"return-value-of-sefblockcheck"},"Return value of SEFBlockCheck"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result. An error is returned if the device is faulty.")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"function-SEFBlockCleanup"},"SEFBlockCleanup"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"struct SEFStatus SEFBlockCleanup(SEFBlockHandle *blockHandle)\n")),(0,l.kt)("p",null,"This function is used to clean up the SEF Block Module by freeing up memory and stopping all related functionality. "),(0,l.kt)("h4",{id:"parameters-of-sefblockcleanup"},"Parameters of SEFBlockCleanup"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Direction"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockHandle ","*"),(0,l.kt)("td",{parentName:"tr",align:null},"blockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"In"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to the SEF Block handle to be used for access to the block instance")))),(0,l.kt)("h4",{id:"return-value-of-sefblockcleanup"},"Return value of SEFBlockCleanup"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFStatus"),(0,l.kt)("td",{parentName:"tr",align:null},"Status and info summarizing result.")))),(0,l.kt)("h4",{id:"return-values-of-sefblockcleanup"},"Return values of SEFBlockCleanup"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Error Value"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"-ENODATA"),(0,l.kt)("td",{parentName:"tr",align:null},"The input block handle is not valid")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"struct-SEFMultiContext"},"SEFMultiContext"),(0,l.kt)("p",null,"I/O request for SEFBlockIO()"),(0,l.kt)("h4",{id:"members-of-sefmulticontext"},"Members of SEFMultiContext"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SEFBlockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"blockHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"SEF Block handle to be used for access to the block instance")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#struct-SEFMultiContext"},"struct SEFMultiContext","*")),(0,l.kt)("td",{parentName:"tr",align:null},"parent"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to an instance of SEFMultiContext used for compound operations")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void(","*",")(struct SEFMultiContext ","*",")"),(0,l.kt)("td",{parentName:"tr",align:null},"completion"),(0,l.kt)("td",{parentName:"tr",align:null},"The function that is called when the transaction is completed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void ","*"),(0,l.kt)("td",{parentName:"tr",align:null},"arg"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer that can be used by caller for any reason")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint64","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"lba"),(0,l.kt)("td",{parentName:"tr",align:null},"Logical block address")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"lbc"),(0,l.kt)("td",{parentName:"tr",align:null},"Logical block count")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint8","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"ioType"),(0,l.kt)("td",{parentName:"tr",align:null},"enum SEFBlockIOType that needs to be performed")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint8","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"flags"),(0,l.kt)("td",{parentName:"tr",align:null},"I/O flags enum SEFBlockIOFlags")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint8","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"readQueue"),(0,l.kt)("td",{parentName:"tr",align:null},"kSEFRead queue override when valid")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"ioWeight"),(0,l.kt)("td",{parentName:"tr",align:null},"I/O weight to override when non-zero")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct iovec","*"),(0,l.kt)("td",{parentName:"tr",align:null},"iov"),(0,l.kt)("td",{parentName:"tr",align:null},"A pointer to the scatter/gather list")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"size","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"iovOffset"),(0,l.kt)("td",{parentName:"tr",align:null},"Starting byte offset into iov array")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"iovcnt"),(0,l.kt)("td",{parentName:"tr",align:null},"The number of elements in the scatter/gather list")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint16","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"qosIndex"),(0,l.kt)("td",{parentName:"tr",align:null},"0 based, used for multi-domain FTL")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFPlacementID"),(0,l.kt)("td",{parentName:"tr",align:null},"placementID"),(0,l.kt)("td",{parentName:"tr",align:null},"Placement ID for writes")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint32","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"numLbl"),(0,l.kt)("td",{parentName:"tr",align:null},"Num logical blocks left in the super block")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"atomic","_","int"),(0,l.kt)("td",{parentName:"tr",align:null},"transferred"),(0,l.kt)("td",{parentName:"tr",align:null},"Counter denoting number of bytes transferred for the transaction")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"atomic","_","int"),(0,l.kt)("td",{parentName:"tr",align:null},"count"),(0,l.kt)("td",{parentName:"tr",align:null},"Reference count, I/O is completed -> 0")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"atomic","_","int"),(0,l.kt)("td",{parentName:"tr",align:null},"error"),(0,l.kt)("td",{parentName:"tr",align:null},"First error for the transaction")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"cancel"),(0,l.kt)("td",{parentName:"tr",align:null},"Set to indicate cancel in progress")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"struct-SEFBlockNotify"},"SEFBlockNotify"),(0,l.kt)("p",null,"Event data sent to a client's notification function. "),(0,l.kt)("p",null,"The notification function is set when SEFBlockInit() is called. "),(0,l.kt)("h4",{id:"members-of-sefblocknotify"},"Members of SEFBlockNotify"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#enum-SEFBlockNotifyType"},"enum SEFBlockNotifyType")),(0,l.kt)("td",{parentName:"tr",align:null},"type"),(0,l.kt)("td",{parentName:"tr",align:null},"Type of notification")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const struct iovec","*"),(0,l.kt)("td",{parentName:"tr",align:null},"iov"),(0,l.kt)("td",{parentName:"tr",align:null},"Vector of buffers to release")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int16","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"iovcnt"),(0,l.kt)("td",{parentName:"tr",align:null},"Count of buffers in iov")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"struct-SEFBlockOption"},"SEFBlockOption"),(0,l.kt)("p",null,"Init time options. "),(0,l.kt)("p",null,"Initialization time options supplied to SEFBlockInit()"),(0,l.kt)("h4",{id:"members-of-sefblockoption"},"Members of SEFBlockOption"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"logLevel"),(0,l.kt)("td",{parentName:"tr",align:null},"Initial log level (Trace = 0 , Debug = 1, Info = 2, Error = 3, Fatal = 4)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"LogHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"logHandle"),(0,l.kt)("td",{parentName:"tr",align:null},"Use an external logger")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"const char ","*"),(0,l.kt)("td",{parentName:"tr",align:null},"instrumentationPath"),(0,l.kt)("td",{parentName:"tr",align:null},"The location for the Unix Domain Socket. Will replace the first two format specifier with UnitIndex and QoSDomainId. Defaults to /tmp/SEFFTLDomain.","[UnitIndex]",".","[QoSDomainId]")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void ","*"),(0,l.kt)("td",{parentName:"tr",align:null},"notifyContext"),(0,l.kt)("td",{parentName:"tr",align:null},"User context passed to notifyFunc()")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"void(","*",")(struct SEFBlockNotify event, void ","*","notifyContext)"),(0,l.kt)("td",{parentName:"tr",align:null},"notifyFunc"),(0,l.kt)("td",{parentName:"tr",align:null},"Set to receive notifications")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"bool"),(0,l.kt)("td",{parentName:"tr",align:null},"delayMount"),(0,l.kt)("td",{parentName:"tr",align:null},"When true, SEFBlockInit() delays mounting until SEFBlockMount() is called")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"struct-SEFBlockConfig"},"SEFBlockConfig"),(0,l.kt)("p",null,"Configuration when calling SEFBlockConfig()"),(0,l.kt)("h4",{id:"members-of-sefblockconfig"},"Members of SEFBlockConfig"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"overprovisioning"),(0,l.kt)("td",{parentName:"tr",align:null},"Percentage of over-provisioning (e.g., 20 for 20 percent)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"unused0"),(0,l.kt)("td",{parentName:"tr",align:null},"Unused member")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"numDomains"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of domains to use for a block-device. 0 indicates all defined domains")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/SEF-SDK/FTL/ftl-api#struct-SEFBlockOption"},"struct SEFBlockOption")),(0,l.kt)("td",{parentName:"tr",align:null},"blockOption"),(0,l.kt)("td",{parentName:"tr",align:null},"Run time options while configuring")))),(0,l.kt)("hr",null),(0,l.kt)("h2",{id:"struct-SEFBlockInfo"},"SEFBlockInfo"),(0,l.kt)("p",null,"Information about a block-module device. "),(0,l.kt)("h4",{id:"members-of-sefblockinfo"},"Members of SEFBlockInfo"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"struct SEFADUsize"),(0,l.kt)("td",{parentName:"tr",align:null},"aduSize"),(0,l.kt)("td",{parentName:"tr",align:null},"Size of ADU and Meta")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int16","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"numPlacementIDs"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of Placement IDs")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"superBlockSize"),(0,l.kt)("td",{parentName:"tr",align:null},"Maximum number of ADUs in a super block")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"superPageSize"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of ADUs in a super page")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"flashWriteSize"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of ADUs to write to avoid padding (e.g., sync write)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"uint64","_","t"),(0,l.kt)("td",{parentName:"tr",align:null},"capacity"),(0,l.kt)("td",{parentName:"tr",align:null},"Capacity in ADUs")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"overprovisioning"),(0,l.kt)("td",{parentName:"tr",align:null},"Percentage of over-provisioning (e.g., 20 for 20 percent)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"int"),(0,l.kt)("td",{parentName:"tr",align:null},"numDomains"),(0,l.kt)("td",{parentName:"tr",align:null},"Number of domains the FTL covers")))),(0,l.kt)("hr",null))}d.isMDXComponent=!0}}]);