"use strict";(self.webpackChunkweb_doc=self.webpackChunkweb_doc||[]).push([[917],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=d(n),u=r,f=c["".concat(s,".").concat(u)]||c[u]||p[u]||i;return n?a.createElement(f,o(o({ref:t},m),{},{components:n})):a.createElement(f,o({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8473:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:2},o="Definitions and Acronyms",l={unversionedId:"definitions",id:"definitions",title:"Definitions and Acronyms",description:"chap-DefinitionsAcronyms}",source:"@site/docs/definitions.md",sourceDirName:".",slug:"/definitions",permalink:"/SEF-SDK/definitions",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docs",previous:{title:"Overview",permalink:"/SEF-SDK/overview"},next:{title:"Security Model",permalink:"/SEF-SDK/security-model"}},s={},d=[{value:"Definitions and Acronyms",id:"tab-DefinitionsAndAcronyms",level:4}],m={toc:d},c="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"chap-DefinitionsAcronyms"},"Definitions and Acronyms"),(0,r.kt)("h4",{id:"tab-DefinitionsAndAcronyms"},"Definitions and Acronyms"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Terms/Acronyms"),(0,r.kt)("th",{parentName:"tr",align:null},"Definition"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Software-Enabled Flash\u2122\ufe0f (SEF)"),(0,r.kt)("td",{parentName:"tr",align:null},"A flash memory-based storage hardware platform that is driven by software. Pronounced as ess e\u0304 ef.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SEF Unit"),(0,r.kt)("td",{parentName:"tr",align:null},"A PCIe\xae\ufe0f flash memory storage device. Contains one or more flash memory dies and provides flash memory service functions. The SEF Unit command set consists of a subset of the NVMe command set with extensions.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Flash Translation Layer (FTL)"),(0,r.kt)("td",{parentName:"tr",align:null},"A mapping of Logical Block Addresses (LBA) to flash memory addresses providing a block based API on top of a flash memory API.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Virtual Device (VD)"),(0,r.kt)("td",{parentName:"tr",align:null},"A set of flash memory dies. A Virtual Device occupies one or more flash memory dies and provides one or more QoS Domains and wear leveling service between QoS Domains. Flash memory dies can only be assigned to one Virtual Device; they are never shared between Virtual Devices. Virtual devices provide true hardware-based isolation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Pseudo Single-Level Cell (pSLC)"),(0,r.kt)("td",{parentName:"tr",align:null},"SEF Units may optionally support programming flash memory as if it\u2019s SLC for increased endurance and performance.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"QoS Domain (QD)"),(0,r.kt)("td",{parentName:"tr",align:null},"A logical construct exposed to the host and enumerated as an SEF Unit node. QoS Domains are created within a single Virtual Device and draw Super Blocks from a common pool within the Virtual Device. One or more QoS Domains may be created within a single Virtual Device. QoS Domains provide software-based isolation, impose quotas on capacity, and are comprised of a set of Super Blocks within a Virtual Device. Super blocks are not shared between QoS Domains. Read/write commands are issued to a specific QoS Domain.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Super Block"),(0,r.kt)("td",{parentName:"tr",align:null},"A set of flash memory blocks spanning all of the dies in a Virtual Device. All flash memory blocks in a Super Block can be programmed and read in parallel.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Logical Block Address (LBA)"),(0,r.kt)("td",{parentName:"tr",align:null},"Represents one component of an optional user-visible addressing interface implemented by an FTL.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ADU"),(0,r.kt)("td",{parentName:"tr",align:null},"Atomic data unit. An SEF-defined internal representation of abstract storage that is the minimum read/write quantum (analogous to the block size of a traditional block device). An SEF Unit may support multiple ADU sizes, and the ADU size is specified when creating a QoS domain. The minimum ADU size is 4096 bytes.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"User Address (UA)"),(0,r.kt)("td",{parentName:"tr",align:null},"Eight bytes of metadata that is stored with an ADU. It is typically used to record the LBA of the ADU. It\u2019s auto incremented when writing to multiple ADUs and can be verified when reading. A portion of the UA is a user defined tag of 24-bits for the application\u2019s use.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Placement ID"),(0,r.kt)("td",{parentName:"tr",align:null},"A placement ID is used when writing data to a QoS Domain. It\u2019s used to group data of a similar lifetime together. ADUs written with the same placement ID are stored in the same Super Blocks.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Root Pointer"),(0,r.kt)("td",{parentName:"tr",align:null},"Provides a bootstrapping mechanism to retrieve metadata from a QoS domain.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"API"),(0,r.kt)("td",{parentName:"tr",align:null},"An Application Programming Interface is a set of rules and protocols that allows different software applications to communicate. The API does not indicate the implementation and various libraries can implement an API differently.")))))}p.isMDXComponent=!0}}]);